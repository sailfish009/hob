(in-package :hob)

(defun parse (input &optional (filename "input"))
  (let* ((file (etypecase input
                 (string input)
                 (stream (let ((buf (make-array (file-length input) :element-type '(unsigned-byte 8))))
                           (read-sequence buf input)
                           (#+sbcl sb-ext:octets-to-string
                            #+allegro excl:octets-to-string
                            #-(or allegro sbcl)(error "Sorry, didn't port to your implementation's octets-to-string yet")
                            buf :external-format :utf8)))))
         (in (make-token-stream :filename filename :file file))
         (*current-filename* filename)
         (*current-file* file))
    (next-token in)
    (when (> (margin in) 0)
      (hob-token-error (cur in) "code must start at column 0"))
    (prog1 (parse-block in) (expect in :eof nil))))

(defun cur (in) (token-stream-cur in))

(defun margin (in) (token-start-col (cur in)))

(defun outdents (tok margin)
  (and (token-new-line tok) (< (token-start-col tok) margin)))
  
(defun ends (in margin)
  (let ((tok (cur in)))
    (or (tok= tok :eof)
        (and (tok= tok :punc) (or (find (token-value tok) ")]};,")
                                  (is-arrow (token-value tok))))
        (outdents tok margin))))

(defun expect (in type val)
  (unless (eat in type val)
    (hob-token-error (cur in) "unexpected ~s, expected ~s" (token-id (cur in))
                     (token-id (make-token :type type :value val)))))

(defun eat (in type &optional val margin)
  (and (tok= (cur in) type val)
       (not (and margin (outdents (cur in) margin)))
       (next-token in)))

(defun unexpected (tok)
  (hob-token-error tok "unexpected ~s" (token-id tok)))

(defun parse-block (in)
  (let* ((margin (margin in))
         (first (parse-tup-expr in (1+ margin))))
    (if (eat in :punc #\;)
        (prog1 (h-seq (cons first (loop :collect (parse-tup-expr in (1+ margin))
                                        :while (eat in :punc #\; margin))))
          (unless (ends in margin) (hob-token-error (cur in) "mixing semicolons and indentation in block")))
        (let ((rest (loop :until (ends in margin)
                       :do (when (/= (margin in) margin)
                             (hob-token-error (cur in) "misaligned continuation of block"))
                       :collect (parse-tup-expr in (1+ margin)))))
          (if rest (h-seq (cons first rest)) first)))))


(defun parse-tup-expr (in margin)
  (let ((first (parse-op-expr in margin)))
    (if (eat in :punc #\, margin)
        (let* ((rest (loop :collect (parse-op-expr in margin) :while (eat in :punc #\, margin)))
               (name (format nil "~{~a~}" (loop :repeat (length rest) :collect #\,))))
          (h-app* (h-word name) (cons first rest)))
        first)))

(defun parse-op-expr (in margin)
  (let ((prefix (eat in :op)))
    (if prefix
        (parse-app-expr in (h-word (token-value prefix)) margin t)
        (let ((head (parse-subscript-expr in)))
          (if (tok= (cur in) :op)
              (let* ((op (token-value (cur in)))
                     (rest (loop :while (eat in :op op margin)
                              :do (when (ends in margin) (hob-token-error (cur in) "unfinished operator application"))
                              :collect (parse-subscript-expr in))))
                (unless (ends in margin) (hob-token-error (cur in) "unexpected continuation after operator application"))
                (h-app* (h-word op) (cons head rest)))
              (parse-app-expr in head margin))))))

(defun parse-app-expr (in head margin &optional no-arrow)
  (let ((tail (loop :for i :from 0 :until (ends in margin) :collect
                 (if (eat in :punc #\:) (parse-block in) (parse-subscript-expr in))))
        (tok (cur in)))
    (cond ((and (not no-arrow)
                (eq (token-type tok) :punc)
                (is-arrow (token-value tok))
                (not (outdents tok margin)))
           (h-app (h-word (token-value tok))
                  (if tail (h-seq (cons head tail)) head)
                  (parse-block in)))
          (tail (h-app* head tail))
          (t head))))

(defun parse-subscript-expr (in)
  (let ((expr (parse-base-expr in)))
    (loop
       (cond ((eat in :punc #\.) (setf expr (h-app (h-word ".") expr (parse-base-expr in))))
             (t (return expr))))))

(defun parse-base-expr (in)
  (let ((tok (next-token in)))
    (case (token-type tok)
      ((:num :string :char) (h-lit (token-value tok)))
      (:word (h-word (token-value tok)))
      (:punc (case (token-value tok)
               (#\( (cond ((eat in :punc #\)) (h-seq nil))
                          ((tok= (cur in) :op)
                           (let ((op (token-value (next-token in))))
                             (expect in :punc #\))
                             (h-word op)))
                          (t (prog1 (parse-block in) (expect in :punc #\))))))
               (#\{ (if (eat in :punc #\})
                        (h-app "{}")
                        (let ((inside (parse-block in)))
                          (expect in :punc #\})
                          (h-app "{}" inside) tok)))
               (#\[ (if (eat in :punc #\])
                        (h-app "[]")
                        (let ((inside (parse-block in)))
                          (expect in :punc #\])
                          (h-app "[]" inside) tok)))
               (t (unexpected tok))))
      (t (unexpected tok)))))
